---
title: cuda
date: 2025-06-06 01:00:00 +/-TTTT
categories: [AI,system]
tags: [AI,system ]  # TAG names should always be lowercase
---
# CUDA算子学习


## cpp review
### 容器
####  一、`unordered_map` 的方法和用法（头文件：`#include <unordered_map>`）

#####  常见声明

```cpp
std::unordered_map<KeyType, ValueType> mp;
```

#####  常用方法与接口

| 方法                      | 说明                                                              |
| ------------------------- | ----------------------------------------------------------------- |
| `mp[key]`                 | 访问（或插入）指定键的值。如果 key 不存在会默认插入 `ValueType()` |
| `mp.at(key)`              | 访问指定键的值（不插入）。如果 key 不存在，抛出异常               |
| `mp.insert({key, value})` | 插入一个键值对。若 key 已存在，不做修改                           |
| `mp.count(key)`           | 返回 key 是否存在（结果是 0 或 1）                                |
| `mp.find(key)`            | 返回指向该元素的迭代器，若不存在返回 `mp.end()`                   |
| `mp.erase(key)`           | 删除指定 key                                                      |
| `mp.clear()`              | 清空整个 map                                                      |
| `mp.size()`               | 返回键值对数量                                                    |
| `mp.empty()`              | 判断是否为空                                                      |
| `mp.begin(), mp.end()`    | 获取迭代器范围（用于遍历）                                        |

##### 🔍 示例：遍历 `unordered_map`

```cpp
for (auto it = mp.begin(); it != mp.end(); ++it) {
    std::cout << "Key: " << it->first << ", Value: " << it->second << std::endl;
}
```

##### 说明

* `it` 是一个指向 `std::pair<const KeyType, ValueType>` 的迭代器
* `it->first` 是键（key）
* `it->second` 是值（value）

---

####  二、`vector` 的方法和接口（头文件：`#include <vector>`）

#####  常见声明

```cpp
std::vector<T> vec;
```

#####  常用方法与接口

| 方法                         | 说明                             |
| ---------------------------- | -------------------------------- |
| `vec.push_back(value)`       | 末尾添加一个元素（拷贝构造）     |
| `vec.emplace_back(args...)`  | 末尾原地构造一个元素（更快）     |
| `vec[i]` 或 `vec.at(i)`      | 访问第 i 个元素，`at` 带越界检查 |
| `vec.size()`                 | 元素个数                         |
| `vec.empty()`                | 是否为空                         |
| `vec.clear()`                | 清空所有元素                     |
| `vec.erase(it)`              | 删除某个位置的元素（传迭代器）   |
| `vec.begin(), vec.end()`     | 获取起始与终止迭代器             |
| `vec.insert(it, value)`      | 在指定位置插入一个元素           |
| `vec.resize(n)`              | 调整大小                         |
| `vec.front()` / `vec.back()` | 返回首元素 / 尾元素              |



---

#### `it->second` 

在遍历 `unordered_map<string, vector<string>> mp` 时：

```cpp
for (auto it = mp.begin(); it != mp.end(); ++it) {
    auto key = it->first;
    auto val_vec = it->second;
}
```

* `it` 是 `std::unordered_map<string, vector<string>>::iterator`
* `*it` 是一个 `std::pair<const string, vector<string>>`
* `it->first` 是键，`it->second` 是值（一个 `vector<string>`）

即 `->second` 访问的是 pair 中的第二个元素。



####  `std::next(it, n)`

* 返回迭代器 `it` 向后移动 `n` 个位置后的新迭代器（默认 `n=1`）
* 不修改原迭代器

####  `std::prev(it, n)`

* 返回迭代器 `it` 向前移动 `n` 个位置后的新迭代器（默认 `n=1`）
* 仅适用于双向迭代器（如 `list`, `map`）

####  `std::distance(first, last)`

* 返回两个迭代器间的距离（元素个数）
* 结果为整数，表示从 `first` 到 `last` 移动了多少步
