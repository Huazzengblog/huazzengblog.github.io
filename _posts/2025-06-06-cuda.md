---
title: cuda
date: 2025-06-06 01:00:00 +/-TTTT
categories: [AI,system]
tags: [AI,system ]  # TAG names should always be lowercase
---
# CUDA算子学习


## cpp review
### 容器
#### 🧩 一、`unordered_map` 的方法和用法（头文件：`#include <unordered_map>`）

##### ✅ 常见声明

```cpp
std::unordered_map<KeyType, ValueType> mp;
```

##### ✅ 常用方法与接口

| 方法                      | 说明                                                              |
| ------------------------- | ----------------------------------------------------------------- |
| `mp[key]`                 | 访问（或插入）指定键的值。如果 key 不存在会默认插入 `ValueType()` |
| `mp.at(key)`              | 访问指定键的值（不插入）。如果 key 不存在，抛出异常               |
| `mp.insert({key, value})` | 插入一个键值对。若 key 已存在，不做修改                           |
| `mp.count(key)`           | 返回 key 是否存在（结果是 0 或 1）                                |
| `mp.find(key)`            | 返回指向该元素的迭代器，若不存在返回 `mp.end()`                   |
| `mp.erase(key)`           | 删除指定 key                                                      |
| `mp.clear()`              | 清空整个 map                                                      |
| `mp.size()`               | 返回键值对数量                                                    |
| `mp.empty()`              | 判断是否为空                                                      |
| `mp.begin(), mp.end()`    | 获取迭代器范围（用于遍历）                                        |

##### 🔍 示例：遍历 `unordered_map`

```cpp
for (auto it = mp.begin(); it != mp.end(); ++it) {
    std::cout << "Key: " << it->first << ", Value: " << it->second << std::endl;
}
```

##### 👇说明

* `it` 是一个指向 `std::pair<const KeyType, ValueType>` 的迭代器
* `it->first` 是键（key）
* `it->second` 是值（value）

---

#### 📦 二、`vector` 的方法和接口（头文件：`#include <vector>`）

##### ✅ 常见声明

```cpp
std::vector<T> vec;
```

##### ✅ 常用方法与接口

| 方法                         | 说明                             |
| ---------------------------- | -------------------------------- |
| `vec.push_back(value)`       | 末尾添加一个元素（拷贝构造）     |
| `vec.emplace_back(args...)`  | 末尾原地构造一个元素（更快）     |
| `vec[i]` 或 `vec.at(i)`      | 访问第 i 个元素，`at` 带越界检查 |
| `vec.size()`                 | 元素个数                         |
| `vec.empty()`                | 是否为空                         |
| `vec.clear()`                | 清空所有元素                     |
| `vec.erase(it)`              | 删除某个位置的元素（传迭代器）   |
| `vec.begin(), vec.end()`     | 获取起始与终止迭代器             |
| `vec.insert(it, value)`      | 在指定位置插入一个元素           |
| `vec.resize(n)`              | 调整大小                         |
| `vec.front()` / `vec.back()` | 返回首元素 / 尾元素              |

##### 🔍 示例：遍历 `vector`

```cpp
for (const auto& val : vec) {
    std::cout << val << std::endl;
}
```

---

#### 🎯 特别解释：`it->second` 是什么意思？

在遍历 `unordered_map<string, vector<string>> mp` 时：

```cpp
for (auto it = mp.begin(); it != mp.end(); ++it) {
    auto key = it->first;
    auto val_vec = it->second;
}
```

* `it` 是 `std::unordered_map<string, vector<string>>::iterator`
* `*it` 是一个 `std::pair<const string, vector<string>>`
* `it->first` 是键，`it->second` 是值（一个 `vector<string>`）

即 `->second` 访问的是 pair 中的第二个元素。

---

#### ✅ 总结小抄

| 表达式                  | 含义                               |
| ----------------------- | ---------------------------------- |
| `mp[key]`               | 获取键对应的值，不存在则插入默认值 |
| `mp.at(key)`            | 获取键对应的值，不存在抛异常       |
| `it->first`             | 当前迭代器指向的键                 |
| `it->second`            | 当前迭代器指向的值                 |
| `vec.emplace_back(val)` | 原地添加元素                       |
| `vec[i]`                | 访问第 i 个元素                    |
| `vec.size()`            | 返回元素个数                       |

在 C++ 中，**迭代器的“下一个”**指的是指向容器中**当前元素之后的一个元素**，你可以通过 `++it` 或 `std::next(it)` 获取。

---

### ✅ 一、获取迭代器的下一个元素的方法

#### 1. `++it`（前缀递增）

```cpp
auto it = container.begin();
++it; // it 现在指向下一个元素
```

* 最常见的写法。
* 修改原 `it` 本身，使其向前移动一个位置。

#### 2. `std::next(it)`

```cpp
#include <iterator>

auto next_it = std::next(it); // 返回 it 的下一个迭代器
```

* 不修改 `it`，而是返回一个新的迭代器（值传递）
* 语义清晰，适合需要保留原迭代器的场景
* 也可以指定步长：`std::next(it, 2)` 表示前进两个位置

#### 3. `it++`（后缀递增）

```cpp
auto old_it = it++;
```

* 会先保留原值，再移动到下一个，效率略低于 `++it`，但用法类似。
* 更常用于表达式中，如：

  ```cpp
  while (it++ != container.end()) // 注意 it++ 的返回值是旧值
  ```

---

### ✅ 二、示例：遍历并访问下一个

```cpp
std::vector<int> nums = {10, 20, 30, 40};

for (auto it = nums.begin(); it != nums.end(); ++it) {
    std::cout << "Current: " << *it;
    auto next_it = std::next(it);
    if (next_it != nums.end()) {
        std::cout << ", Next: " << *next_it;
    }
    std::cout << std::endl;
}
```

**输出：**

```
Current: 10, Next: 20
Current: 20, Next: 30
Current: 30, Next: 40
Current: 40
```

---

### ⚠️ 注意事项

* 你不能对 `end()` 做 `++`：`container.end()` 是**最后一个元素的下一个位置（不存在元素）**

  ```cpp
  ++container.end(); // ❌ 未定义行为（UB）
  ```
* 对于 `map`/`unordered_map` 这样的容器，`it->second` 获取的是当前元素的值，你也可以使用 `std::next(it)->second` 访问下一个值（但要确保不越界）。

---

### ✅ 总结小抄

| 表达式             | 说明                               |
| ------------------ | ---------------------------------- |
| `++it`             | 原地移动到下一个                   |
| `std::next(it)`    | 获取下一个迭代器（不修改原 it）    |
| `it++`             | 先返回当前，再移动到下一个         |
| `std::next(it, n)` | 向前移动 n 个位置                  |
| `std::prev(it)`    | 获取前一个迭代器（双向容器中可用） |

需要我讲 `prev()`、`distance()`、或自定义结构如何实现迭代器吗？
