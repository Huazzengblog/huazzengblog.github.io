---
title: cuda
date: 2025-06-06 01:00:00 +/-TTTT
categories: [AI,system]
tags: [AI,system ]  # TAG names should always be lowercase
---
# CUDA算子学习


## cpp review
### 容器
####  一、`unordered_map` 的方法和用法（头文件：`#include <unordered_map>`）

#####  常见声明

```cpp
std::unordered_map<KeyType, ValueType> mp;
```

#####  常用方法与接口

| 方法                      | 说明                                                              |
| ------------------------- | ----------------------------------------------------------------- |
| `mp[key]`                 | 访问（或插入）指定键的值。如果 key 不存在会默认插入 `ValueType()` |
| `mp.at(key)`              | 访问指定键的值（不插入）。如果 key 不存在，抛出异常               |
| `mp.insert({key, value})` | 插入一个键值对。若 key 已存在，不做修改                           |
| `mp.count(key)`           | 返回 key 是否存在（结果是 0 或 1）                                |
| `mp.find(key)`            | 返回指向该元素的迭代器，若不存在返回 `mp.end()`                   |
| `mp.erase(key)`           | 删除指定 key                                                      |
| `mp.clear()`              | 清空整个 map                                                      |
| `mp.size()`               | 返回键值对数量                                                    |
| `mp.empty()`              | 判断是否为空                                                      |
| `mp.begin(), mp.end()`    | 获取迭代器范围（用于遍历）                                        |

##### 🔍 示例：遍历 `unordered_map`

```cpp
for (auto it = mp.begin(); it != mp.end(); ++it) {
    std::cout << "Key: " << it->first << ", Value: " << it->second << std::endl;
}
```

##### 说明

* `it` 是一个指向 `std::pair<const KeyType, ValueType>` 的迭代器
* `it->first` 是键（key）
* `it->second` 是值（value）

---

####  二、`vector` 的方法和接口（头文件：`#include <vector>`）

#####  常见声明

```cpp
std::vector<T> vec;
```

#####  常用方法与接口

| 方法                         | 说明                             |
| ---------------------------- | -------------------------------- |
| `vec.push_back(value)`       | 末尾添加一个元素（拷贝构造）     |
| `vec.emplace_back(args...)`  | 末尾原地构造一个元素（更快）     |
| `vec[i]` 或 `vec.at(i)`      | 访问第 i 个元素，`at` 带越界检查 |
| `vec.size()`                 | 元素个数                         |
| `vec.empty()`                | 是否为空                         |
| `vec.clear()`                | 清空所有元素                     |
| `vec.erase(it)`              | 删除某个位置的元素（传迭代器）   |
| `vec.begin(), vec.end()`     | 获取起始与终止迭代器             |
| `vec.insert(it, value)`      | 在指定位置插入一个元素           |
| `vec.resize(n)`              | 调整大小                         |
| `vec.front()` / `vec.back()` | 返回首元素 / 尾元素              |



---

#### `it->second` 

在遍历 `unordered_map<string, vector<string>> mp` 时：

```cpp
for (auto it = mp.begin(); it != mp.end(); ++it) {
    auto key = it->first;
    auto val_vec = it->second;
}
```

* `it` 是 `std::unordered_map<string, vector<string>>::iterator`
* `*it` 是一个 `std::pair<const string, vector<string>>`
* `it->first` 是键，`it->second` 是值（一个 `vector<string>`）

即 `->second` 访问的是 pair 中的第二个元素。



####  `std::next(it, n)`

* 返回迭代器 `it` 向后移动 `n` 个位置后的新迭代器（默认 `n=1`）
* 不修改原迭代器

####  `std::prev(it, n)`

* 返回迭代器 `it` 向前移动 `n` 个位置后的新迭代器（默认 `n=1`）
* 仅适用于双向迭代器（如 `list`, `map`）

####  `std::distance(first, last)`

* 返回两个迭代器间的距离（元素个数）
* 结果为整数，表示从 `first` 到 `last` 移动了多少步
#### `std::unordered_set` 常用接口与用法速查表

| 分类    | 接口/语法                                            | 说明                               | 时间复杂度           |
| ----- | ------------------------------------------------ | -------------------------------- | --------------- |
| 基本操作  | `unordered_set<T> s;`                            | 创建一个空集合                          | O(1)            |
|       | `s.insert(x);`                                   | 插入元素 `x`，若已存在不会重复插入              | 平均 O(1)，最坏 O(n) |
|       | `s.erase(x);`                                    | 删除元素 `x`，若不存在则无操作                | 平均 O(1)，最坏 O(n) |
|       | `s.clear();`                                     | 清空集合所有元素                         | O(n)            |
|       | `s.size();`                                      | 返回当前元素数量                         | O(1)            |
|       | `s.empty();`                                     | 判断集合是否为空                         | O(1)            |
| 查找相关  | `s.count(x)`                                     | 判断元素 `x` 是否存在：存在返回 1，否则返回 0      | 平均 O(1)         |
|       | `s.find(x)`                                      | 返回指向元素 `x` 的迭代器，若不存在返回 `s.end()` | 平均 O(1)         |
|       | `s.contains(x)` *(C++20+)*                       | 判断集合中是否包含元素 `x`（更简洁）             | 平均 O(1)         |
| 遍历    | `for (auto x : s)`                               | 范围 for 循环遍历所有元素                  | O(n)            |
|       | `for (auto it = s.begin(); it != s.end(); ++it)` | 通过迭代器遍历所有元素                      | O(n)            |
| 迭代器相关 | `s.begin()`                                      | 返回指向第一个元素的迭代器（无序）                | O(1)            |
|       | `s.end()`                                        | 返回超尾迭代器                          | O(1)            |
| 哈希相关  | `s.bucket_count()`                               | 返回当前使用的哈希桶数量                     | O(1)            |
|       | `s.load_factor()`                                | 返回当前负载因子（元素数 / 桶数）               | O(1)            |
|       | `s.rehash(n)`                                    | 重新组织哈希桶数量，至少为 n                  | O(n)            |
