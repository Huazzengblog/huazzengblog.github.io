---
title: information security
date: 2025-02-25 00:45:00 +/-TTTT
categories: 25spring
tags: [25spring]
---
# 信息安全
## 密码学
### 古典密码

#### 分类
* 按照加密
  * 替代密码
    * caser 
    
  * 置换密码
    * 羊皮传书

  * 乘积密码
    * 组合操作明文 形成密文
* 按照密钥类型
  * 对称加密
  * 非对称加密
* 按照解密方式
  * 分组解密
  * 流解密

#### 如何设计一个强的密码
1. 密钥数量
2. 使得攻击者没有比穷举更好的方法

#### 安全的定义
* 无条件安全
  * one-time pad
* 计算安全
> For all reasonable encryption algorithms, have to assume computational security where it either takes too long, or is too expensive, to bother breaking the cipher. 

#### 密码攻击方式
* chosen ciphertext 
* ciphertext only 
* known plaintext 
* chosen plaintext 
* chosen text 

#### Playfair Cipher
* 分组加密， 多对一，同一个明文个字母对应不同的密文字母组合
* Playfair Key Matrix
  * a 5X5 matrix of letters based on a keyword 
* 加密方式
	1.	相同字母对插入填充字母：如果一对字母是重复的，就插入一个填充字母（通常是 ‘X’ 或其他字符）。比如“balloon”中的“ll”会被替换为“lX”，变成“ba lx lo on”。
	2.	同一行规则：如果一对字母位于同一行，那么每个字母都用该行中右边的字母替代。如果字母在该行的末尾，则会从头开始进行环绕替换。例如：
	•	如果“ar”位于如 a b c d e 这样的行中，那么替换后变为“RM”。
	3.	同一列规则：如果一对字母位于同一列，那么每个字母都用该列下方的字母替代。如果字母在该列的底部，则会环绕到顶部。例如：
	•	如果“mu”位于 m n o p q 这样的列中，那么替换后变为“CM”。
	4.	矩形规则（如果不在同一行或列）：如果两字母既不在同一行，也不在同一列，它们会形成一个矩形。每个字母都会被替换为其所在行中，另一字母所在列的字母。
* 攻击方式
   * Frequency Analysis
   * Bigrams and Common Word Patterns
     * 通过常用单词的分析identify the ciphertext

#### Vigenère Cipher
* 流加密，逐个加密，同一个明文字母会对应不同的秘闻字母
* 加密方法
  * 在 Vigenère cipher 中，字母的加密是逐个字母进行的，密钥的长度与明文的长度相同或者更长。每个明文字母和密钥字母通过位置上的字母表偏移来加密。
  * 这里的 一对多 意味着一个明文字母（例如 ‘A’）在不同的密钥字母下可能会加密成多个不同的密文字母。比如，如果密钥为 ‘B’，明文字母 ‘A’ 会加密成 ‘B’，如果密钥为 ‘C’，明文字母 ‘A’ 就会加密成 ‘C’。
  * 所以，一个明文字母 在不同的密钥组合下可以对应不同的密文字母，从而形成 一对多 的加密映射。
* 攻击方法
  * Frequency Analysis
    * 确定密钥长度
      * 寻找重复的字母组合（公共子串）：密文中如果出现相同的字母对（例如 “FBE” 和 “FBE”），说明它们可能由相同的密钥字母加密产生（因为密钥是重复的）。找到这些重复的字母对并测量它们之间的间隔。
	  * 计算最大间隔：如果重复出现的字母对之间的间隔是相同的，很可能是由于密钥的某个长度引起的。通过这些间隔，可以猜测出密钥的长度。
    * 针对单个字母表进行攻击
  * Kasiski Examination
    ![alt text](https://raw.githubusercontent.com/huazZengblog/huazZengblog.github.io/main/_posts/img/info_security/image.png)
  * Friedman Test
    * 重合指数（Index of Coincidence）描述目标文本中字母频率的不匀性
    ![alt text](https://raw.githubusercontent.com/huazZengblog/huazZengblog.github.io/main/_posts/img/info_security/indexofcoincidence-1.png)
    ![alt text](https://raw.githubusercontent.com/huazZengblog/huazZengblog.github.io/main/_posts/img/info_security/indexofcoincidence-2.png)
    * 密钥长度的估计
      * 如果文本是自然语言（如英语），IC 高，通常在 0.065 左右
      * 步骤 1：将密文分组
        设定一个可能的密钥长度  k ，然后按照该长度将密文分成  k  组，即：
          •	第一组包含第 1、 k+1 、 2k+1  … 个字符，
          •	第二组包含第 2、 k+2 、 2k+2  … 个字符，依此类推。
      *	步骤 2：计算每组的 IC
        如果某个  k  使得每组的 IC 接近 0.065，则这个  k  可能是密钥长度。
      * 步骤 3：分析每组字符
        如果密钥长度正确，每组字符就相当于使用相同的凯撒密码加密，可以进一步使用频率分析破解。
    * 增强方式
      * Autokey cipher
      * LFSR cipher：通过计算方式增加密钥长度
#### Rotor Machines


### 现代分组密码
#### concept
* 分组密码
* 流密码
* 同步流密码
#### 一般原理
* 理想分组密码 - feistel
  * S盒和P盒都在F内
  * based on concept of invertible product cipher
    * why？：解密和加密时经过的结构相同，只是使用的密钥序列相反


> Develop a block cipher with a key length of k bits and a block length of n bits, allowing a total of 2k possible transformation

generated by gpt
>Feistel 密码结构是一种基于轮函数的分组加密框架，通过左右交换和 XOR 运算实现加密和解密。其最大优势在于解密过程与加密过程类似，使其成为构造安全、高效对称密码的基础。

* S-P-N
  * substitution-permutation 
  * SPN Primitives
    * S-Box 内部存在替换表
    * P-Box 内部存在置换表 
  * S-P-N 是一个以S-Box和P-Box为单元的神经网络
  * Confusion and Diffusion
  * 雪崩效应

#### 实例
* feistel
  * DES
    * [blog1](https://zhuanlan.zhihu.com/p/665593533)
    * 明文分组
      * ![alt text](https://raw.githubusercontent.com/huazZengblog/huazZengblog.github.io/main/_posts/img/info_security/DES.png)
      * ![alt text](https://raw.githubusercontent.com/huazZengblog/huazZengblog.github.io/main/_posts/img/info_security/DES-F.png)
    * 子密钥生成
      ![alt text](https://raw.githubusercontent.com/huazZengblog/huazZengblog.github.io/main/_posts/img/info_security/DES-K.png)
    * 雪崩效应
      * 输入的微小变化（如一个比特的改变）会导致输出发生巨大变化（大量比特翻转）。
    * 破解密码：
      *   暴力破解 2的56次方
      *   差分破解 2的47次方
  * AES


> AES 与 DES 的区别
	1.	算法设计：
	•	DES 使用 64-bit 分组，并且基于 Feistel 网络 结构，采用 56-bit 密钥。
	•	AES 使用 128-bit 分组，并采用不同的结构，通常称为 代换-置换网络（Substitution-Permutation Network, SPN）。
	2.	密钥长度：
	•	DES 使用 56-bit 密钥（实际为 64-bit 密钥，但 8 位是校验位，不参与加密）。
	•	AES 支持三种密钥长度：128-bit、192-bit、256-bit，比 DES 的密钥更长，因此更安全。
	3.	加密轮数：
	•	DES 进行 16 轮加密。
	•	AES 根据密钥长度的不同，进行 10 轮（128-bit 密钥）、12 轮（192-bit 密钥） 或 14 轮（256-bit 密钥） 加密。
	4.	安全性：
	•	DES 的 56-bit 密钥 被认为过短，现代计算机可以通过暴力破解轻松攻破。因此，DES 已经被认为不再安全。
	•	AES 采用更长的密钥（128-bit、192-bit、256-bit），提供了更高的安全性，并且被认为能抗得住现代计算机的攻击。
	5.	效率：
	•	DES 的计算过程相对较为简单，历史上在硬件上执行速度较快，但在软件实现上速度较慢。
	•	AES 设计时考虑了 硬件和软件效率，并且相较于 DES，AES 在大多数平台上都提供了更高的效率。
为什么 AES 替代了 DES
	•	安全性：DES 的 56-bit 密钥长度在现代计算机的处理能力下太短，容易受到暴力破解攻击。
	•	AES 作为替代：为了提供更强的安全性，美国国家标准与技术研究院（NIST）举办了一个公开竞赛，选择了 Rijndael 算法作为新的加密标准，这就是现在的 AES。AES 支持更长的密钥长度（128-bit、192-bit、256-bit）并且在设计上更加现代化，因此替代了 DES。



### Public Key Cryptography
* principle
  * 参与方B容易通过计算产生出一对密钥（公开密钥KUb ，私有密钥KRb ）
  * 发送方A很容易计算产生密文
  * 接收方B通过计算解密密文
  * 敌对方即使知道公开密钥KUb ，要确定私有密钥KRb 在计算上是不可行的
  * 敌对方即使知道公开密钥KUb 和密文C，要确定明文M在计算上是不可行的
  * 密码对互相之间可以交换使用
    * 公钥加密的内容可以被私钥解出
    * 私钥加密的内容可以被公钥解出（签名验证）
* 数字签名
  * 用处
    * 身份验证
    * 抗抵赖
  * 使用私钥加密的信息，可以被任意公钥用户解开
  * 嵌套加密，使得数字签名也保密
    * eg. $E_{KuA}(E_{KrB}(M))$

* RSA
  * 分组加密
  * 采用的单向函数是大素数相乘，相乘很容易，但因子分解很困难
  * 基于数论中的Fermat（小）定理实现
  * key的生成
    * p,q 为两个大素数，$ n=p * q，ø(n)=(p-1)(q-1)$,概率性算法判定
    * selecting at random the e where 1<e<ø(n), gcd(e,ø(n))=1 
    * solve following equation to find the d 
    * e.d=1 mod ø(n) and 0≤d≤n 
    * publish their public encryption key: PU={e,n} 
    * keep secret private decryption key: PR={d,n} 
  * key generation
    * Determining two prime numbers, p and q (Miller-Rabin Test)
    * Selecting either e or d and calculating the other (Extended Euclid)


  * 加解密算法
    * to encrypt a message M the sender:
      * obtains public key of recipient PU={e,n} 
      * computes: C = $M^e$  mod n, where 0≤M<n
    * to decrypt the ciphertext C the owner:
      * uses their private key PR={d,n} 
      * computes: M = $C^d$ mod n 
    * prove:
      * in RSA have:
        * n=p.q
        * ø(n)=(p-1)(q-1) 
        * carefully chose e & d to be inverses mod ø(n) hence e.d=1+k.ø(n) for some k
      * hence :	$C^d = M^{e.d }= M^{1+k.ø(n)} = M^1.(M^{ø(n)})^k 
              = M^{1}.(1)^{k} = M^1 = M mod n $
          * eg.
  * 加解密算法优化
    * 幂运算模的优化
  * 攻击方式
    * possible approaches to attacking RSA are:
    * brute force key search (infeasible given size of numbers)
    * mathematical attacks (based on difficulty of computing ø(n), by factoring modulus n) 分解n
    * timing attacks (on running of decryption) 记时攻击
    * chosen ciphertext attacks (given properties of RSA)
  * 


* 密钥交换

### PKI
* Public Key Infrastructure
  * CA
  * digital certificate
* digtal certificate format
  * x.509
* 一个完整的PKI应该包括
  * 证书授权中心(CA)
  * 证书库
  * 证书注销
  * 密钥备份和恢复
  * 自动密钥更新
  * 密钥历史档案
  * 交叉认证
  * 时间戳
  * 客户端软件

* PKI组成
  ![pki](https://raw.githubusercontent.com/huazZengblog/huazZengblog.github.io/main/_posts/img/info_security/pki.png)
  *  PKI Application（PKI 应用）
    位于图的最上方，代表基于PKI技术开发和使用的各类应用程序。这些应用程序依赖PKI提供的安全服务，如身份认证、数据加密和数字签名等，来保障其安全运行。例如，网上银行系统、电子商务平台等，它们通过PKI应用来确保用户身份的真实性以及数据传输的安全性。

  * 中间层组件
    1. **Certificate Authority（CA，证书颁发机构）**：负责生成、颁发和管理数字证书。数字证书将公钥与特定的实体（如用户、服务器等）绑定在一起，CA通过严格的身份验证流程，确保证书持有者的身份真实可靠。例如，当一个网站申请SSL证书时，CA会对网站的身份进行验证，然后颁发证书，使网站能够实现安全的HTTPS连接。
    2. **Registration Authority（RA，注册机构）**：作为CA的辅助机构，主要负责处理证书申请的审核工作。RA会对证书申请者的身份信息进行核实，收集相关资料，并将审核通过的申请提交给CA进行证书颁发。例如，在企业内部的PKI系统中，RA可能会负责审核员工的证书申请，确保只有合法的员工能够获得相应的证书。 
    3. **Certificate Issuance System（证书签发系统）** ：这是实现证书颁发流程自动化的系统，它与CA和RA协同工作，根据审核结果签发数字证书，并进行证书的存储、更新和撤销等管理操作。

  * 底层支撑
    1. **PKI Policy（PKI策略）**：定义了PKI系统的使用规则、管理规范和安全要求等内容。PKI策略确保了整个PKI系统的一致性和安全性，包括证书的申请流程、有效期设置、密钥管理等方面的规定。例如，PKI策略可能会规定证书的最长有效期为一年，以及在何种情况下需要重新申请证书等。
    2. **Software and Hardware Systems（软硬件系统）**：为PKI系统的运行提供基础的技术支撑。硬件系统可能包括服务器、存储设备、加密设备等，用于存储密钥、运行CA和RA的服务程序等；软件系统则包括操作系统、数据库管理系统以及PKI相关的软件组件等，它们共同协作来实现PKI系统的各项功能。
* 签发流程
  ![pki_flow](https://raw.githubusercontent.com/huazZengblog/huazZengblog.github.io/main/_posts/img/info_security/pki-2.png)

  * 1. 用户请求流程
    - **User's request**：表示用户发起的请求。
    - **Accept request**：接收用户请求的模块，负责初步处理用户请求。
    - **RA（Registration Authority）**：注册机构，它接收来自 “Accept request” 的请求，并进一步处理用户的注册相关事务。
    - **Secure Server**：安全服务器，图中有两个，分别与RA和CA server相连。它们负责在传输过程中对数据进行加密和安全处理，确保数据的保密性和完整性。

  * 2. 证书颁发机构（CA）相关
    - **CA server（Certificate Authority server）**：证书颁发机构服务器，负责颁发、管理和撤销数字证书。它通过安全服务器与RA进行交互，处理用户的证书相关请求。

  * 3. 数据库和目录服务器
    - **Database server**：数据库服务器，用于存储系统相关的数据，如用户信息、证书信息等。图中有两个数据库服务器，分别与左侧和右侧的系统组件相连。
    - **LDAP server（Lightweight Directory Access Protocol server）**：轻量级目录访问协议服务器，用于存储和管理目录信息，如用户身份信息、证书状态等。图中也有两个LDAP服务器，分别与不同的系统组件相连。
  * 4. 证书用户交互
    - **Certificate user**：证书用户，他们可以进行证书下载或查询操作。证书用户通过 “Certificate download or query” 操作与数据库服务器和LDAP服务器交互，获取所需的证书信息。

  * 系统整体功能
  这个系统架构的主要功能是处理用户的请求，特别是与证书相关的请求。通过RA进行用户注册请求的初步处理，然后通过安全服务器与CA server进行交互，完成证书的颁发、管理等操作。数据库服务器和LDAP服务器用于存储和管理相关数据，以支持系统的正常运行。证书用户可以通过系统进行证书的下载和查询操作。

* 证书撤销机制
  * 原因：超过时限，私钥泄漏，密钥更换，用户变化
这篇文章详细介绍了公钥基础设施（PKI）的相关知识，涵盖了其技术背景、组成部分、信任关系以及应用场景等多个方面。



* PKI信任关系
 - **层次结构信任模型**
    - 单CA模型存在局限性，大型CA机构可建立层次结构，包括根CA和中间CA。根CA自签名，依次对下级CA签名，叶子节点CA对安全主体签名。主体需信任根CA，证书链验证从根证书开始，沿层次树向下验证签名。
    - 根ca会对自己做自签名，自签名意味着这是证书链的起点
    - 证书链
      ```
      用户证书
        ⬆
      中间CA证书
        ⬆
      根CA证书（自签名）
      ```
      - 验证过程
      ```
      步骤 1️⃣：服务器发送证书链
      服务器将用户证书 + 中间CA证书发送给客户端（例如浏览器）。

      步骤 2️⃣：客户端验证证书链
      客户端会：
        1.	检查证书是否过期或吊销；
        2.	从操作系统或浏览器中的“受信任的根CA”列表中查找根CA；
        3.	逐级验证签名是否有效：
        •	用中间CA的公钥验证用户证书；
        •	用根CA的公钥验证中间CA证书；
        4.	验证通过则信任连接，显示“安全”。
      ```
 - **交叉认证**
    - **交叉认证**：不同CA层次结构间可通过交叉认证建立信任关系，有单向和双向交叉认证，受名字约束、路径长度约束、策略约束等限制。
      - 路径长度约束：当交叉认证链路过长则不再信任
      - 认证过程：先找当前节点的签发ca，查看当前ca的信任关系，再找当前ca的发出去的证书（找到当前ca信任的ca）
    - **认证模型**
      - 完全网状
      - 不完全网状
- 混合信任模型

* PKI的应用
 - **相关标准**
    - 包括Certificates（X.509 v.3）、交叉认证（PKIX group in IETF，RFC 2459）、智能卡/硬件插件（PKCS #11）以及PKCS系列标准等。PKCS系列标准涵盖证书申请、更新、撤销、加密、签名等多方面内容。
 - **基本服务**
    - 提供报文/身份认证（采用数字签名技术）、完整性（数字签名或哈希函数）、保密性（公钥分发密钥加密数据）和不可否认（发送方数字签名，接收方收条 + 数字签名）等服务。
 - **应用场景**
    - 基本应用包括文件保护、E - mail、Web应用等，其他应用如VPN、SSL/TLS、XML/e - business、WAP等。国内已有多家CA，分为区域类、行业类、商业类、内部自用类。随着互联网技术发展，PKI在保障网络应用安全方面发挥重要作用，且各国也有相关立法，如美国的电子签名法（2000年）和中国的电子签名法（2004年，个别应用有限制）。



### 身份认证
#### 1. 身份认证的基本概念
身份认证是确保用户或系统在访问某个资源或服务时的真实性与合法性的过程。通常，身份认证有三个基本要素：
- **知识因素**（Something you know）：如密码或PIN。
- **持有因素**（Something you have）：如身份卡、手机、硬件令牌等。
- **生物特征因素**（Something you are）：如指纹、虹膜扫描、面部识别等。

身份认证的目的是验证用户或系统是否是它所声称的身份。

#### 2. 基于口令的身份认证
基于口令的身份认证是最常见的身份验证方法之一。用户通过输入一个预设的密码（口令）来证明自己的身份。口令通常会在传输和存储时进行加密，以防止被窃取。

- **优点**：简单易用，成本低。
- **缺点**：易受到暴力破解、社会工程学攻击等威胁。
- **改进**：可以通过多因素认证（如短信验证码、手机认证）来增强安全性。

#### 3. Unix口令
在Unix系统中，用户的口令信息通常保存在一个叫做`/etc/passwd`的文件中（或者更安全的`/etc/shadow`文件）。Unix系统会使用加密算法（如MD5或SHA）对用户口令进行加密存储。

Unix系统通常采用以下方式处理口令：
- **加密存储**：存储的不是明文口令，而是经过哈希加密后的口令。
- **口令验证**：当用户输入口令时，系统会将输入的口令进行同样的加密处理，并与存储的加密值进行比较。
以下是你提到的攻击类型的详细介绍：
#### 攻击方法
##### 1. 重放攻击（Replay Attack）
重放攻击是指攻击者截获并重放合法用户与服务器之间的通信数据，从而冒充用户进行身份认证。由于认证过程中的口令（或其它凭证）通常是固定的，并且如果没有额外的防护措施（如时间戳、随机质询等），攻击者可以通过捕获有效的认证消息，并在之后的某个时间点重新发送这些消息来伪造认证。

**防护方法**：
- **时间戳**：每个认证请求中包含一个时间戳，服务器验证请求是否在允许的时间窗口内。
- **一次性口令（OTP）**：使用动态生成的口令（如TOTP或HOTP），每次认证都需要新的口令，防止重放。
- **质询-应答机制**：使用质询（challenge）和应答（response）来验证身份，每次请求的内容都不同。

##### 2. 穷举攻击（Brute Force Attack）
穷举攻击是一种暴力破解方法，攻击者尝试所有可能的输入组合，直到找到正确的密码或密钥。在密码学中，穷举攻击常用于破解加密算法或暴力猜测密码。

**在口令破解中的应用**：
- **8个字符密码**：一个8字符的密码，如果字符集是数字、字母和特殊符号（例如，ASCII字符集），会有大量可能的组合。比如使用大小写字母、数字和常见符号的密码空间，8个字符的密码大约有 **40-50 bits** 的穷举空间。
  - 如果字符集为62个字符（26大写字母 + 26小写字母 + 10数字），那么8个字符的密码空间为 \(62^8 \approx 218,340,105,584,896\) 种可能。
  - 如果使用更多字符（如ASCII码表中的所有字符），密码空间会显著增加。
- **防护方法**：
  - 使用长且复杂的密码。
  - 实现密码锁定策略，在多次输入错误密码后暂时锁定账户。
  - 引入多因素认证，增强安全性。

##### 3. 字典攻击（Dictionary Attack）
字典攻击是一种利用字典列表进行密码破解的攻击方式。攻击者使用一个常见的密码列表（字典），并尝试逐一比对所有常见密码，直到找到正确的密码。字典攻击的效率较穷举攻击更高，因为它只针对常见的密码进行尝试。

**字典攻击的特点**：
- 攻击者使用密码字典（通常包含常见的密码、词语、变种等）进行攻击。
- 适用于口令简单、常见的情况。
- 对于易猜的密码（如“password”、“123456”）特别有效。

**防护方法**：
- **复杂密码策略**：要求用户设置包含大小写字母、数字和特殊符号的密码。
- **逐步增加密码长度**：增加密码长度会显著增加破解的时间和难度。
- **启用多因素认证（MFA）**：增加额外的身份验证方式，减少字典攻击的效果。

##### 4. 在线字典攻击（Online Dictionary Attack）
在线字典攻击是指攻击者通过直接与目标系统进行交互（通常是通过登录界面）来尝试字典列表中的密码。这种攻击利用了目标系统的认证接口，通过反复输入字典中的密码，直到找到正确的密码。

**特征**：
- 攻击者直接与服务器进行交互，一次尝试一个密码，依赖目标系统的反馈（如错误提示）。
- 需要实时验证每个密码的正确性。

**防护方法**：
- **账户锁定机制**：在多次失败的登录尝试后锁定账户一段时间。
- **CAPTCHA**：增加人工验证机制，防止自动化攻击。
- **延迟响应**：每次密码尝试后增加延迟，降低攻击效率。

##### 5. 离线字典攻击（Offline Dictionary Attack）
离线字典攻击是指攻击者通过事先捕获加密的认证数据（如密码的哈希值）并将其脱机破解。在这种情况下，攻击者并不需要与目标系统交互，而是在自己的计算机上使用字典列表暴力破解哈希值，直到找到匹配的密码。

**特征**：
- 攻击者获取加密的密码哈希值后，可以离线进行字典攻击。
- 攻击效率取决于目标系统的密码存储方式（如哈希算法的强度、是否有盐值）。

**防护方法**：
- **使用盐值（Salt）**：将随机数据添加到密码中进行哈希处理，确保相同的密码生成不同的哈希值。
- **强哈希算法**：采用现代的哈希算法（如bcrypt、scrypt、Argon2）并配置较高的计算成本，增加破解的难度。
- **加密存储**：避免存储明文密码，仅存储加密的哈希值。

##### 总结
- **重放攻击**：通过截获和重发数据实现攻击，可以通过时间戳、动态口令等防护。
- **穷举攻击**：通过暴力尝试所有可能的密码组合来破解密码，防护方式包括使用复杂且长的密码。
- **字典攻击**：利用预先准备的密码字典来进行攻击，防护方式包括使用复杂的密码和启用多因素认证。
- **在线字典攻击**：通过与目标系统交互逐个尝试密码，防护方式包括账户锁定和CAPTCHA。
- **离线字典攻击**：通过捕获哈希值脱机破解，防护方式包括盐值和强哈希算法。





#### 4. 动态口令（One-Time Password, OTP）
动态口令是一种一次性使用的口令，每次认证时生成一个新的口令。动态口令通常用于多因素认证，增加了口令被窃取后的风险，减少了重复使用口令的安全隐患。

- **实现方式**：动态口令常通过硬件令牌（如RSA SecurID）或手机APP（如Google Authenticator）生成。
- **常见类型**：
  - **基于时间的OTP（TOTP）**：每隔一定时间生成一个新的口令。
  - **基于事件的OTP（HOTP）**：每次请求时生成一个新的口令。

#### 5. 质询与应答认证技术（Challenge-Response Authentication）
质询与应答认证技术是通过一个“质询”和一个“应答”来验证用户身份的方法。认证服务器向客户端发送一个质询（通常是一个随机数），客户端用自己的密钥（或口令）对质询进行加密并返回应答。服务器验证应答是否正确，从而验证身份。

- **优点**：避免了明文传输口令，提高了安全性。
- **缺点**：需要确保质询和应答的安全性，防止中间人攻击。

#### 6. Needham-Schroeder协议
Needham-Schroeder协议是一种基于质询-应答的身份认证协议，旨在通过密钥交换来实现安全的认证。协议的核心思想是利用对称密钥加密来确保双方的身份。

- **流程**：
  1. 客户端A向认证服务器发送请求，申请与服务器B建立会话。
  2. 认证服务器生成会话密钥并通过加密方式将会话密钥发送给客户端A和服务器B。
  3. 客户端A和服务器B通过交换加密的会话密钥来相互验证身份。

Needham-Schroeder协议存在一些安全漏洞，特别是容易受到重放攻击，因此在实际应用中进行了改进。

#### 7. KERBEROS协议
Kerberos是一个计算机网络认证协议，旨在提供强大的身份验证服务。它使用对称密钥加密进行认证，并通过票据的方式确保通信双方身份的验证。

- **流程**：
  1. 客户端向认证服务器（AS）请求一个票据授权票（TGT）。
  2. 认证服务器向客户端发送加密的TGT，客户端将此票据用于向服务请求会话密钥。
  3. 客户端向目标服务发送包含TGT和请求的服务票据。
  4. 服务端验证票据，成功后允许客户端访问服务。

- **优点**：通过票据和对称加密可以有效防止中间人攻击、重放攻击等安全威胁。
- **缺点**：依赖于中心认证服务器（KDC），如果KDC被攻击或失效，整个系统的安全性会受到影响。

Kerberos广泛应用于操作系统（如Windows、Linux）和企业级网络中。

