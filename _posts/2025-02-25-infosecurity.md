---
title: information security
date: 2025-02-25 00:45:00 +/-TTTT
categories: 25spring
tags: [25spring]
---
# 信息安全
## 密码学
### 古典密码

#### 分类
* 按照加密
  * 替代密码
    * caser 
    
  * 置换密码
    * 羊皮传书

  * 乘积密码
    * 组合操作明文 形成密文
* 按照密钥类型
  * 对称加密
  * 非对称加密
* 按照解密方式
  * 分组解密
  * 流解密

#### 如何设计一个强的密码
1. 密钥数量
2. 使得攻击者没有比穷举更好的方法

#### 安全的定义
* 无条件安全
  * one-time pad
* 计算安全
> For all reasonable encryption algorithms, have to assume computational security where it either takes too long, or is too expensive, to bother breaking the cipher. 

#### 密码攻击方式
* chosen ciphertext 
* ciphertext only 
* known plaintext 
* chosen plaintext 
* chosen text 

#### Playfair Cipher
* 分组加密， 多对一，同一个明文个字母对应不同的密文字母组合
* Playfair Key Matrix
  * a 5X5 matrix of letters based on a keyword 
* 加密方式
	1.	相同字母对插入填充字母：如果一对字母是重复的，就插入一个填充字母（通常是 ‘X’ 或其他字符）。比如“balloon”中的“ll”会被替换为“lX”，变成“ba lx lo on”。
	2.	同一行规则：如果一对字母位于同一行，那么每个字母都用该行中右边的字母替代。如果字母在该行的末尾，则会从头开始进行环绕替换。例如：
	•	如果“ar”位于如 a b c d e 这样的行中，那么替换后变为“RM”。
	3.	同一列规则：如果一对字母位于同一列，那么每个字母都用该列下方的字母替代。如果字母在该列的底部，则会环绕到顶部。例如：
	•	如果“mu”位于 m n o p q 这样的列中，那么替换后变为“CM”。
	4.	矩形规则（如果不在同一行或列）：如果两字母既不在同一行，也不在同一列，它们会形成一个矩形。每个字母都会被替换为其所在行中，另一字母所在列的字母。
* 攻击方式
   * Frequency Analysis
   * Bigrams and Common Word Patterns
     * 通过常用单词的分析identify the ciphertext

#### Vigenère Cipher
* 流加密，逐个加密，同一个明文字母会对应不同的秘闻字母
* 加密方法
  * 在 Vigenère cipher 中，字母的加密是逐个字母进行的，密钥的长度与明文的长度相同或者更长。每个明文字母和密钥字母通过位置上的字母表偏移来加密。
  * 这里的 一对多 意味着一个明文字母（例如 ‘A’）在不同的密钥字母下可能会加密成多个不同的密文字母。比如，如果密钥为 ‘B’，明文字母 ‘A’ 会加密成 ‘B’，如果密钥为 ‘C’，明文字母 ‘A’ 就会加密成 ‘C’。
  * 所以，一个明文字母 在不同的密钥组合下可以对应不同的密文字母，从而形成 一对多 的加密映射。
* 攻击方法
  * Frequency Analysis
    * 确定密钥长度
      * 寻找重复的字母组合（公共子串）：密文中如果出现相同的字母对（例如 “FBE” 和 “FBE”），说明它们可能由相同的密钥字母加密产生（因为密钥是重复的）。找到这些重复的字母对并测量它们之间的间隔。
	  * 计算最大间隔：如果重复出现的字母对之间的间隔是相同的，很可能是由于密钥的某个长度引起的。通过这些间隔，可以猜测出密钥的长度。
    * 针对单个字母表进行攻击
  * Kasiski Examination
    ![alt text](https://raw.githubusercontent.com/huazZengblog/huazZengblog.github.io/main/_posts/img/info_security/image.png)
  * Friedman Test
    * 重合指数（Index of Coincidence）描述目标文本中字母频率的不匀性
    ![alt text](https://raw.githubusercontent.com/huazZengblog/huazZengblog.github.io/main/_posts/img/info_security/indexofcoincidence-1.png)
    ![alt text](https://raw.githubusercontent.com/huazZengblog/huazZengblog.github.io/main/_posts/img/info_security/indexofcoincidence-2.png)
    * 密钥长度的估计
      * 如果文本是自然语言（如英语），IC 高，通常在 0.065 左右
      * 步骤 1：将密文分组
        设定一个可能的密钥长度  k ，然后按照该长度将密文分成  k  组，即：
          •	第一组包含第 1、 k+1 、 2k+1  … 个字符，
          •	第二组包含第 2、 k+2 、 2k+2  … 个字符，依此类推。
      *	步骤 2：计算每组的 IC
        如果某个  k  使得每组的 IC 接近 0.065，则这个  k  可能是密钥长度。
      * 步骤 3：分析每组字符
        如果密钥长度正确，每组字符就相当于使用相同的凯撒密码加密，可以进一步使用频率分析破解。
    * 增强方式
      * Autokey cipher
      * LFSR cipher：通过计算方式增加密钥长度
#### Rotor Machines


### 现代分组密码
#### concept
* 分组密码
* 流密码
* 同步流密码
#### 一般原理
* 理想分组密码 - feistel
  * S盒和P盒都在F内
  * based on concept of invertible product cipher
    * why？：解密和加密时经过的结构相同，只是使用的密钥序列相反


> Develop a block cipher with a key length of k bits and a block length of n bits, allowing a total of 2k possible transformation

generated by gpt
>Feistel 密码结构是一种基于轮函数的分组加密框架，通过左右交换和 XOR 运算实现加密和解密。其最大优势在于解密过程与加密过程类似，使其成为构造安全、高效对称密码的基础。

* S-P-N
  * substitution-permutation 
  * SPN Primitives
    * S-Box 内部存在替换表
    * P-Box 内部存在置换表 
  * S-P-N 是一个以S-Box和P-Box为单元的神经网络
  * Confusion and Diffusion
  * 雪崩效应

#### 实例
* feistel
  * DES
    * [blog1](https://zhuanlan.zhihu.com/p/665593533)
    * 明文分组
      * ![alt text](https://raw.githubusercontent.com/huazZengblog/huazZengblog.github.io/main/_posts/img/info_security/DES.png)
      * ![alt text](https://raw.githubusercontent.com/huazZengblog/huazZengblog.github.io/main/_posts/img/info_security/DES-F.png)
    * 子密钥生成
      ![alt text](https://raw.githubusercontent.com/huazZengblog/huazZengblog.github.io/main/_posts/img/info_security/DES-K.png)
    * 雪崩效应
      * 输入的微小变化（如一个比特的改变）会导致输出发生巨大变化（大量比特翻转）。
    * 破解密码：
      *   暴力破解 2的56次方
      *   差分破解 2的47次方
  * AES


> AES 与 DES 的区别
	1.	算法设计：
	•	DES 使用 64-bit 分组，并且基于 Feistel 网络 结构，采用 56-bit 密钥。
	•	AES 使用 128-bit 分组，并采用不同的结构，通常称为 代换-置换网络（Substitution-Permutation Network, SPN）。
	2.	密钥长度：
	•	DES 使用 56-bit 密钥（实际为 64-bit 密钥，但 8 位是校验位，不参与加密）。
	•	AES 支持三种密钥长度：128-bit、192-bit、256-bit，比 DES 的密钥更长，因此更安全。
	3.	加密轮数：
	•	DES 进行 16 轮加密。
	•	AES 根据密钥长度的不同，进行 10 轮（128-bit 密钥）、12 轮（192-bit 密钥） 或 14 轮（256-bit 密钥） 加密。
	4.	安全性：
	•	DES 的 56-bit 密钥 被认为过短，现代计算机可以通过暴力破解轻松攻破。因此，DES 已经被认为不再安全。
	•	AES 采用更长的密钥（128-bit、192-bit、256-bit），提供了更高的安全性，并且被认为能抗得住现代计算机的攻击。
	5.	效率：
	•	DES 的计算过程相对较为简单，历史上在硬件上执行速度较快，但在软件实现上速度较慢。
	•	AES 设计时考虑了 硬件和软件效率，并且相较于 DES，AES 在大多数平台上都提供了更高的效率。
为什么 AES 替代了 DES
	•	安全性：DES 的 56-bit 密钥长度在现代计算机的处理能力下太短，容易受到暴力破解攻击。
	•	AES 作为替代：为了提供更强的安全性，美国国家标准与技术研究院（NIST）举办了一个公开竞赛，选择了 Rijndael 算法作为新的加密标准，这就是现在的 AES。AES 支持更长的密钥长度（128-bit、192-bit、256-bit）并且在设计上更加现代化，因此替代了 DES。



### Public Key Cryptography
* principle
  * 参与方B容易通过计算产生出一对密钥（公开密钥KUb ，私有密钥KRb ）
  * 发送方A很容易计算产生密文
  * 接收方B通过计算解密密文
  * 敌对方即使知道公开密钥KUb ，要确定私有密钥KRb 在计算上是不可行的
  * 敌对方即使知道公开密钥KUb 和密文C，要确定明文M在计算上是不可行的
  * 密码对互相之间可以交换使用
    * 公钥加密的内容可以被私钥解出
    * 私钥加密的内容可以被公钥解出（签名验证）
* 数字签名
  * 用处
    * 身份验证
    * 抗抵赖
  * 使用私钥加密的信息，可以被任意公钥用户解开
  * 嵌套加密，使得数字签名也保密
    * eg. $E_{KuA}(E_{KrB}(M))$

* RSA
  * 分组加密
  * 采用的单向函数是大素数相乘，相乘很容易，但因子分解很困难
  * 基于数论中的Fermat（小）定理实现
  * key的生成
    * p,q 为两个大素数，$ n=p * q，ø(n)=(p-1)(q-1)$,概率性算法判定
    * selecting at random the e where 1<e<ø(n), gcd(e,ø(n))=1 
    * solve following equation to find the d 
    * e.d=1 mod ø(n) and 0≤d≤n 
    * publish their public encryption key: PU={e,n} 
    * keep secret private decryption key: PR={d,n} 
  * key generation
    * Determining two prime numbers, p and q (Miller-Rabin Test)
    * Selecting either e or d and calculating the other (Extended Euclid)


  * 加解密算法
    * to encrypt a message M the sender:
      * obtains public key of recipient PU={e,n} 
      * computes: C = $M^e$  mod n, where 0≤M<n
    * to decrypt the ciphertext C the owner:
      * uses their private key PR={d,n} 
      * computes: M = $C^d$ mod n 
    * prove:
      * in RSA have:
        * n=p.q
        * ø(n)=(p-1)(q-1) 
        * carefully chose e & d to be inverses mod ø(n) hence e.d=1+k.ø(n) for some k
      * hence :	$C^d = M^{e.d }= M^{1+k.ø(n)} = M^1.(M^{ø(n)})^k 
              = M^{1}.(1)^{k} = M^1 = M mod n $
          * eg.
  * 加解密算法优化
    * 幂运算模的优化
  * 攻击方式
    * possible approaches to attacking RSA are:
    * brute force key search (infeasible given size of numbers)
    * mathematical attacks (based on difficulty of computing ø(n), by factoring modulus n) 分解n
    * timing attacks (on running of decryption) 记时攻击
    * chosen ciphertext attacks (given properties of RSA)
  * 


* 密钥交换

### PKI
* Public Key Infrastructure
  * CA
  * digital certificate
* digtal certificate format
  * x.509
* 一个完整的PKI应该包括
  * 证书授权中心(CA)
  * 证书库
  * 证书注销
  * 密钥备份和恢复
  * 自动密钥更新
  * 密钥历史档案
  * 交叉认证
  * 时间戳
  * 客户端软件

* PKI组成
  ![pki](https://raw.githubusercontent.com/huazZengblog/huazZengblog.github.io/main/_posts/img/info_security/pki.png)
  *  PKI Application（PKI 应用）
    位于图的最上方，代表基于PKI技术开发和使用的各类应用程序。这些应用程序依赖PKI提供的安全服务，如身份认证、数据加密和数字签名等，来保障其安全运行。例如，网上银行系统、电子商务平台等，它们通过PKI应用来确保用户身份的真实性以及数据传输的安全性。

  * 中间层组件
    1. **Certificate Authority（CA，证书颁发机构）**：负责生成、颁发和管理数字证书。数字证书将公钥与特定的实体（如用户、服务器等）绑定在一起，CA通过严格的身份验证流程，确保证书持有者的身份真实可靠。例如，当一个网站申请SSL证书时，CA会对网站的身份进行验证，然后颁发证书，使网站能够实现安全的HTTPS连接。
    2. **Registration Authority（RA，注册机构）**：作为CA的辅助机构，主要负责处理证书申请的审核工作。RA会对证书申请者的身份信息进行核实，收集相关资料，并将审核通过的申请提交给CA进行证书颁发。例如，在企业内部的PKI系统中，RA可能会负责审核员工的证书申请，确保只有合法的员工能够获得相应的证书。 
    3. **Certificate Issuance System（证书签发系统）** ：这是实现证书颁发流程自动化的系统，它与CA和RA协同工作，根据审核结果签发数字证书，并进行证书的存储、更新和撤销等管理操作。

  * 底层支撑
    1. **PKI Policy（PKI策略）**：定义了PKI系统的使用规则、管理规范和安全要求等内容。PKI策略确保了整个PKI系统的一致性和安全性，包括证书的申请流程、有效期设置、密钥管理等方面的规定。例如，PKI策略可能会规定证书的最长有效期为一年，以及在何种情况下需要重新申请证书等。
    2. **Software and Hardware Systems（软硬件系统）**：为PKI系统的运行提供基础的技术支撑。硬件系统可能包括服务器、存储设备、加密设备等，用于存储密钥、运行CA和RA的服务程序等；软件系统则包括操作系统、数据库管理系统以及PKI相关的软件组件等，它们共同协作来实现PKI系统的各项功能。
* 签发流程
  ![pki_flow](https://raw.githubusercontent.com/huazZengblog/huazZengblog.github.io/main/_posts/img/info_security/pki-2.png)

  * 1. 用户请求流程
    - **User's request**：表示用户发起的请求。
    - **Accept request**：接收用户请求的模块，负责初步处理用户请求。
    - **RA（Registration Authority）**：注册机构，它接收来自 “Accept request” 的请求，并进一步处理用户的注册相关事务。
    - **Secure Server**：安全服务器，图中有两个，分别与RA和CA server相连。它们负责在传输过程中对数据进行加密和安全处理，确保数据的保密性和完整性。

  * 2. 证书颁发机构（CA）相关
    - **CA server（Certificate Authority server）**：证书颁发机构服务器，负责颁发、管理和撤销数字证书。它通过安全服务器与RA进行交互，处理用户的证书相关请求。

  * 3. 数据库和目录服务器
    - **Database server**：数据库服务器，用于存储系统相关的数据，如用户信息、证书信息等。图中有两个数据库服务器，分别与左侧和右侧的系统组件相连。
    - **LDAP server（Lightweight Directory Access Protocol server）**：轻量级目录访问协议服务器，用于存储和管理目录信息，如用户身份信息、证书状态等。图中也有两个LDAP服务器，分别与不同的系统组件相连。
  * 4. 证书用户交互
    - **Certificate user**：证书用户，他们可以进行证书下载或查询操作。证书用户通过 “Certificate download or query” 操作与数据库服务器和LDAP服务器交互，获取所需的证书信息。

  * 系统整体功能
  这个系统架构的主要功能是处理用户的请求，特别是与证书相关的请求。通过RA进行用户注册请求的初步处理，然后通过安全服务器与CA server进行交互，完成证书的颁发、管理等操作。数据库服务器和LDAP服务器用于存储和管理相关数据，以支持系统的正常运行。证书用户可以通过系统进行证书的下载和查询操作。

* 证书撤销机制
  * 原因：超过时限，私钥泄漏，密钥更换，用户变化
这篇文章详细介绍了公钥基础设施（PKI）的相关知识，涵盖了其技术背景、组成部分、信任关系以及应用场景等多个方面。



* PKI信任关系
 - **层次结构信任模型**
    - 单CA模型存在局限性，大型CA机构可建立层次结构，包括根CA和中间CA。根CA自签名，依次对下级CA签名，叶子节点CA对安全主体签名。主体需信任根CA，证书链验证从根证书开始，沿层次树向下验证签名。
    - 根ca会对自己做自签名，自签名意味着这是证书链的起点
    - 证书链
      ```
      用户证书
        ⬆
      中间CA证书
        ⬆
      根CA证书（自签名）
      ```
      - 验证过程
      ```
      步骤 1️⃣：服务器发送证书链
      服务器将用户证书 + 中间CA证书发送给客户端（例如浏览器）。

      步骤 2️⃣：客户端验证证书链
      客户端会：
        1.	检查证书是否过期或吊销；
        2.	从操作系统或浏览器中的“受信任的根CA”列表中查找根CA；
        3.	逐级验证签名是否有效：
        •	用中间CA的公钥验证用户证书；
        •	用根CA的公钥验证中间CA证书；
        4.	验证通过则信任连接，显示“安全”。
      ```
 - **交叉认证**
    - **交叉认证**：不同CA层次结构间可通过交叉认证建立信任关系，有单向和双向交叉认证，受名字约束、路径长度约束、策略约束等限制。
      - 路径长度约束：当交叉认证链路过长则不再信任
      - 认证过程：先找当前节点的签发ca，查看当前ca的信任关系，再找当前ca的发出去的证书（找到当前ca信任的ca）
    - **认证模型**
      - 完全网状
      - 不完全网状
- 混合信任模型

* PKI的应用
 - **相关标准**
    - 包括Certificates（X.509 v.3）、交叉认证（PKIX group in IETF，RFC 2459）、智能卡/硬件插件（PKCS #11）以及PKCS系列标准等。PKCS系列标准涵盖证书申请、更新、撤销、加密、签名等多方面内容。
 - **基本服务**
    - 提供报文/身份认证（采用数字签名技术）、完整性（数字签名或哈希函数）、保密性（公钥分发密钥加密数据）和不可否认（发送方数字签名，接收方收条 + 数字签名）等服务。
 - **应用场景**
    - 基本应用包括文件保护、E - mail、Web应用等，其他应用如VPN、SSL/TLS、XML/e - business、WAP等。国内已有多家CA，分为区域类、行业类、商业类、内部自用类。随着互联网技术发展，PKI在保障网络应用安全方面发挥重要作用，且各国也有相关立法，如美国的电子签名法（2000年）和中国的电子签名法（2004年，个别应用有限制）。



### 身份认证
#### 1. 身份认证的基本概念
身份认证是确保用户或系统在访问某个资源或服务时的真实性与合法性的过程。通常，身份认证有三个基本要素：
- **知识因素**（Something you know）：如密码或PIN。
- **持有因素**（Something you have）：如身份卡、手机、硬件令牌等。
- **生物特征因素**（Something you are）：如指纹、虹膜扫描、面部识别等。

身份认证的目的是验证用户或系统是否是它所声称的身份。

#### 2. 基于口令的身份认证
基于口令的身份认证是最常见的身份验证方法之一。用户通过输入一个预设的密码（口令）来证明自己的身份。口令通常会在传输和存储时进行加密，以防止被窃取。

- **优点**：简单易用，成本低。
- **缺点**：易受到暴力破解、社会工程学攻击等威胁。
- **改进**：可以通过多因素认证（如短信验证码、手机认证）来增强安全性。

#### 3. Unix口令
在Unix系统中，用户的口令信息通常保存在一个叫做`/etc/passwd`的文件中（或者更安全的`/etc/shadow`文件）。Unix系统会使用加密算法（如MD5或SHA）对用户口令进行加密存储。

Unix系统通常采用以下方式处理口令：
- **加密存储**：存储的不是明文口令，而是经过哈希加密后的口令。
- **口令验证**：当用户输入口令时，系统会将输入的口令进行同样的加密处理，并与存储的加密值进行比较。
以下是你提到的攻击类型的详细介绍：
#### 攻击方法
##### 1. 重放攻击（Replay Attack）
重放攻击是指攻击者截获并重放合法用户与服务器之间的通信数据，从而冒充用户进行身份认证。由于认证过程中的口令（或其它凭证）通常是固定的，并且如果没有额外的防护措施（如时间戳、随机质询等），攻击者可以通过捕获有效的认证消息，并在之后的某个时间点重新发送这些消息来伪造认证。

**防护方法**：
- **时间戳**：每个认证请求中包含一个时间戳，服务器验证请求是否在允许的时间窗口内。
- **一次性口令（OTP）**：使用动态生成的口令（如TOTP或HOTP），每次认证都需要新的口令，防止重放。
- **质询-应答机制**：使用质询（challenge）和应答（response）来验证身份，每次请求的内容都不同。

##### 2. 穷举攻击（Brute Force Attack）
穷举攻击是一种暴力破解方法，攻击者尝试所有可能的输入组合，直到找到正确的密码或密钥。在密码学中，穷举攻击常用于破解加密算法或暴力猜测密码。

**在口令破解中的应用**：
- **8个字符密码**：一个8字符的密码，如果字符集是数字、字母和特殊符号（例如，ASCII字符集），会有大量可能的组合。比如使用大小写字母、数字和常见符号的密码空间，8个字符的密码大约有 **40-50 bits** 的穷举空间。
  - 如果字符集为62个字符（26大写字母 + 26小写字母 + 10数字），那么8个字符的密码空间为 \(62^8 \approx 218,340,105,584,896\) 种可能。
  - 如果使用更多字符（如ASCII码表中的所有字符），密码空间会显著增加。
- **防护方法**：
  - 使用长且复杂的密码。
  - 实现密码锁定策略，在多次输入错误密码后暂时锁定账户。
  - 引入多因素认证，增强安全性。

##### 3. 字典攻击（Dictionary Attack）
字典攻击是一种利用字典列表进行密码破解的攻击方式。攻击者使用一个常见的密码列表（字典），并尝试逐一比对所有常见密码，直到找到正确的密码。字典攻击的效率较穷举攻击更高，因为它只针对常见的密码进行尝试。

**字典攻击的特点**：
- 攻击者使用密码字典（通常包含常见的密码、词语、变种等）进行攻击。
- 适用于口令简单、常见的情况。
- 对于易猜的密码（如“password”、“123456”）特别有效。

**防护方法**：
- **复杂密码策略**：要求用户设置包含大小写字母、数字和特殊符号的密码。
- **逐步增加密码长度**：增加密码长度会显著增加破解的时间和难度。
- **启用多因素认证（MFA）**：增加额外的身份验证方式，减少字典攻击的效果。

##### 4. 在线字典攻击（Online Dictionary Attack）
在线字典攻击是指攻击者通过直接与目标系统进行交互（通常是通过登录界面）来尝试字典列表中的密码。这种攻击利用了目标系统的认证接口，通过反复输入字典中的密码，直到找到正确的密码。

**特征**：
- 攻击者直接与服务器进行交互，一次尝试一个密码，依赖目标系统的反馈（如错误提示）。
- 需要实时验证每个密码的正确性。

**防护方法**：
- **账户锁定机制**：在多次失败的登录尝试后锁定账户一段时间。
- **CAPTCHA**：增加人工验证机制，防止自动化攻击。
- **延迟响应**：每次密码尝试后增加延迟，降低攻击效率。

##### 5. 离线字典攻击（Offline Dictionary Attack）
离线字典攻击是指攻击者通过事先捕获加密的认证数据（如密码的哈希值）并将其脱机破解。在这种情况下，攻击者并不需要与目标系统交互，而是在自己的计算机上使用字典列表暴力破解哈希值，直到找到匹配的密码。

**特征**：
- 攻击者获取加密的密码哈希值后，可以离线进行字典攻击。
- 攻击效率取决于目标系统的密码存储方式（如哈希算法的强度、是否有盐值）。

**防护方法**：
- **使用盐值（Salt）**：将随机数据添加到密码中进行哈希处理，确保相同的密码生成不同的哈希值。
- **强哈希算法**：采用现代的哈希算法（如bcrypt、scrypt、Argon2）并配置较高的计算成本，增加破解的难度。
- **加密存储**：避免存储明文密码，仅存储加密的哈希值。

##### 总结
- **重放攻击**：通过截获和重发数据实现攻击，可以通过时间戳、动态口令等防护。
- **穷举攻击**：通过暴力尝试所有可能的密码组合来破解密码，防护方式包括使用复杂且长的密码。
- **字典攻击**：利用预先准备的密码字典来进行攻击，防护方式包括使用复杂的密码和启用多因素认证。
- **在线字典攻击**：通过与目标系统交互逐个尝试密码，防护方式包括账户锁定和CAPTCHA。
- **离线字典攻击**：通过捕获哈希值脱机破解，防护方式包括盐值和强哈希算法。





#### 4. 动态口令（One-Time Password, OTP）
动态口令是一种一次性使用的口令，每次认证时生成一个新的口令。动态口令通常用于多因素认证，增加了口令被窃取后的风险，减少了重复使用口令的安全隐患。

- **实现方式**：动态口令常通过硬件令牌（如RSA SecurID）或手机APP（如Google Authenticator）生成。
- **常见类型**：
  - **基于时间的OTP（TOTP）**：每隔一定时间生成一个新的口令。
  - **基于事件的OTP（HOTP）**：每次请求时生成一个新的口令。

#### 5. 质询与应答认证技术（Challenge-Response Authentication）
* 质询与应答是构造更复杂的交互式认证协议的基本组件
  * 步骤1：用户A（客户端）发送认证请求给服务器。

  * 步骤2：服务器生成一个质询（Challenge C）。

  * 步骤3：客户端计算基于质询的密码（P = f(C)），然后发送应答（P）。

  * 步骤4：服务器验证客户端发送的密码 P 是否正确。如果正确，认证成功。
  
##### 基于对称密钥
###### 单向认证
* Bob -- 》 Alice: rb
* Alice --》 Bob: EK(rb, B)
* Bob收到后检验 rb 是否是它刚发送给A的Challenge随机数
* 同时检验B的标识 “B” - 是为了防止反射攻击(reflection attack)，报文中的“B” 标记了报文的方向
  * reflection attack ： 
    * B   → I(A):     rb 
    * I(A) →  B:       rb 
    * B     → I(A):     EK{rb} 
    * I(A) →  B:      EK{rb}  
    * 这样就可以拿到应答


* rb 要求必须不能重复, 并且是随机的
* 防止重放攻击 replay attack

###### 双向认证
* Bob-> Alice: rb
* Alice -> Bob: EK(ra, rb, B)  
  * Alice Challenge Bob
* Bob -> Alice: EK(ra, rb)
##### 基于基于对称密钥的MAC

###### 单向认证

* Bob -> Alice: rb
* Alice -> Bob: ra, hK(ra, rb, B)
###### 双向认证
* Bob -> Alice: rb
* Alice -> Bob: ra, hK(ra, rb, B)
* Bob -> Alice: hK(ra, rb, A)


##### 基于数字签名
###### 单向认证
* Bob -> Alice: rB（随机数）
* Alice -> Bob: certA, rA, B, SA(rA, rB, B)
###### 双向认证
* Bob -> Alice: rB
* Alice -> Bob: certA, rA, B, SA(rA,rB,B)
* Bob -> Alice: certB, A, SB(rA,rB,A)


#### 6. Needham-Schroeder协议
Needham-Schroeder协议是一种基于质询-应答的身份认证协议，旨在通过密钥交换来实现安全的认证。协议的核心思想是利用对称密钥加密来确保双方的身份。

- **流程**：
  1. 客户端A向认证服务器发送请求，申请与服务器B建立会话。
  2. 认证服务器生成会话密钥并通过加密方式将会话密钥发送给客户端A和服务器B。
  3. 客户端A和服务器B通过交换加密的会话密钥来相互验证身份。

Needham-Schroeder协议存在一些安全漏洞，特别是容易受到重放攻击，因此在实际应用中进行了改进。

#### 7. KERBEROS协议
Kerberos是一个计算机网络认证协议，旨在提供强大的身份验证服务。它使用对称密钥加密进行认证，并通过票据的方式确保通信双方身份的验证。

- **流程**：
  1. 客户端向认证服务器（AS）请求一个票据授权票（TGT）。
  2. 认证服务器向客户端发送加密的TGT，客户端将此票据用于向服务请求会话密钥。
  3. 客户端向目标服务发送包含TGT和请求的服务票据。
  4. 服务端验证票据，成功后允许客户端访问服务。

- **优点**：通过票据和对称加密可以有效防止中间人攻击、重放攻击等安全威胁。
- **缺点**：依赖于中心认证服务器（KDC），如果KDC被攻击或失效，整个系统的安全性会受到影响。

Kerberos广泛应用于操作系统（如Windows、Linux）和企业级网络中。



## 区块链


### 区块链的核心概念

**1. 去中心化账本：**
区块链充当一个公开的、分布式的账本，每个参与者都可以持有一份副本。 它不跟踪账户余额，而是记录每笔交易，包括付款人、收款人和金额。这种透明度，加上大多数人的共识，确保了账本的完整性。链中的每个“区块”类似于账本中的一页，包含多个交易并按顺序链接到前一个区块

**2. 确保完整性：交易和历史记录：**
区块链的安全性依赖于确保两种类型的完整性：
    * **交易完整性：** 每个区块内的交易必须是完整且不可篡改的。 这是通过使用默克尔树（一种哈希树）来实现的，它为区块中的整个交易集生成数字指纹，从而实现高效验证。 
    * **交易历史完整性：** 区块链本身必须是防篡改的，以确保过去的交易不能被更改或删除。这是通过在当前区块的头部包含前一个区块头部的哈希值来实现的，从而创建了一个按时间顺序排列且不可破坏的链接。 

**3. 工作量证明 (PoW)：**
矿工负责通过记录最近的交易来创建新的区块。 这个“挖矿”过程涉及解决一个计算密集型难题：找到一个随机数（Nonce），当它与区块头部的其他数据（包括前一个区块的哈希值和新交易的默克尔根）结合时，会产生一个低于系统设定的特定难度目标的哈希值。这就是所谓的工作量证明，证明矿工付出了大量的计算努力。  难度大约每两周（2016个区块）动态调整一次，以维持平均10分钟的区块创建时间。

**4. 通过公钥密码学实现身份标识、身份验证和抗抵赖：**
公钥密码学在识别用户、验证交易和确保抗抵赖性方面起着至关重要的作用。 笔交易都由付款人使用其私钥进行数字签名。 任何人都可以使用付款人的公钥验证此签名，从而确认交易的真实性和完整性，并防止付款人事后否认该交易。  钱包地址由公钥的哈希值得出。 比特币使用SECP256K1椭圆曲线密码算法。 

**5. 匿名性（假名性）：**
虽然所有交易在账本上都是公开的，但公钥背后的真实身份是保密的。  用户可以生成多个公钥以进一步模糊其交易历史，从而提供一定程度的假名性。 

### 矿工的角色与激励机制

矿工执行收集交易、创建新区块并对其进行验证的关键工作。  作为对其努力的激励，成功创建有效区块的矿工将获得新铸造的比特币和交易费奖励。最初，每个区块的奖励是50个比特币，但这个数量大约每210,000个区块减半，以控制通货膨胀，最终将比特币总供应量限制在约2100万个。  一旦区块奖励减少，矿工将主要从交易费中获得收入。 

### 解决潜在问题


* **同时创建区块（分叉）：** 如果多个矿工大致在同一时间创建了有效区块，网络会暂时分叉。  协议通过采用最长的链作为有效链来解决此问题，矿工会转而在其上构建。 
* **双重支付：** 攻击者可能会在收到商品或服务后尝试撤销交易。 为防止这种情况，建议收款人在其交易被打包进区块后，等待后续几个区块（通常是六个）添加到链中，从而使得攻击者创建一个忽略该交易的更长替代链在计算上变得不可行。 
* **通货膨胀：** 预定的区块奖励递减计划和有限的总供应量旨在防止不受控制的通货膨胀。 
* **篡改：** 加密哈希、工作量证明和去中心化共识机制（需要“51%多数”的诚实参与者）的结合，使得篡改区块链变得极其困难，并且对于拥有多数算力的矿工来说在经济上也是不合理的。 2018年针对比特币黄金（BTG）的51%攻击的真实案例，攻击者成功进行了双重支付，给交易所造成了重大的经济损失，并促使其进行网络升级。 

### 安全特性总结

比特币的设计解决了几个关键的安全问题：
* **完整性：** 通过数字签名和加密哈希来保护，以防止双重支付和交易逆转。 
* **身份验证：** 公钥密码学确保用户向正确的实体付款。
* **隐私性：** 通过假名性实现，因为公钥不直接与真实身份相关联。
* **可用性：** P2P网络允许进行交易，分布式存储确保数据持久性。 





### 矿工创建区块的流程

矿工在区块链网络中扮演着至关重要的角色，他们负责验证交易并将这些交易打包成新的区块，然后将新区块添加到现有的区块链上。这个过程通常被称为“挖矿”。

以下是矿工创建区块的主要步骤：

1.  **收集交易 (Collecting Transactions)**:
    * 当用户发起一笔交易时（例如，A向B支付比特币），这笔交易会被广播到整个比特币网络中。
    * 网络中的矿工节点会收集这些未经确认的交易。每个矿工都会维护一个“内存池”（Mempool），其中存储着这些待处理的交易。
    * 矿工通常会优先选择那些支付了较高交易费的交易进行打包，因为交易费是矿工收入的一部分。

2.  **验证交易 (Verifying Transactions)**:
    * 矿工会验证其收集到的交易的有效性。这包括检查：
        * 交易的数字签名是否有效（即付款人是否真的授权了这笔交易）。
        * 付款人是否有足够的余额来支付这笔交易。
        * 交易的格式是否正确，是否符合协议规则（例如，没有双重花费等）。

3.  **构建候选区块 (Constructing a Candidate Block)**:
    * 矿工从内存池中选择一批有效的交易，并将它们组织起来。
    * **区块体 (Block Body)**: 这些被选中的交易构成了新区块的“区块体”。
    * **区块头 (Block Header)**: 接着，矿工需要构建“区块头”。区块头包含了关于这个区块的关键元数据，主要包括：
        * **版本号 (Version)**: 区块的版本号。
        * **前一区块头的哈希值 (Previous Block Hash / Prev\_hash)**: 这是指向上一个区块的指针，确保了区块链的链式结构和历史不可篡改性。
        * **默克尔树根哈希 (Merkle Root Hash)**: 将区块体中所有交易通过默克尔树（一種 HASH 二叉树）算法生成一个唯一的哈希值。这个哈希值可以高效地验证区块中任何一笔交易是否存在且未被篡改，确保了“交易本身的完整性”。
        * **时间戳 (Timestamp)**: 该区块产生的近似时间。
        * **难度目标 (Difficulty Target)**: 当前网络的挖矿难度。
        * **Nonce (随机数)**: 这是一个由矿工尝试填入的数字，用于工作量证明计算。

4.  **执行工作量证明 (Proof-of-Work - PoW)**:
    * 这是挖矿过程中最核心也是计算量最大的部分。
    * 矿工需要找到一个合适的 Nonce 值，使得将该 Nonce 值与区块头中的其他字段（如前一区块哈希、默克尔根、时间戳、难度目标等）一起进行哈希运算（比特币中使用的是 SHA256(SHA256(Block Header))）后，得到的哈希结果小于当前网络设定的难度目标值 E。
    * 这个难度目标值 E 通常是一个非常小的数字，意味着哈希结果必须以一长串的“0”开头。
    * 由于哈希函数的特性（输出看起来是随机的，且微小的输入改变会导致完全不同的输出），找到这个 Nonce 值没有捷径，只能通过不断地尝试不同的 Nonce 值（通常是从0开始递增或者随机选择）并计算哈希，直到找到一个满足条件的为止。
    * 这个过程非常消耗计算资源和电力，因此被称为“工作量证明”。第一个成功找到有效 Nonce 的矿工，就相当于完成了创建这个区块的工作量。

5.  **广播新区块 (Broadcasting the New Block)**:
    * 一旦矿工找到了满足条件的 Nonce，他就成功地“挖出”了一个新的区块。
    * 该矿工会立即将这个新区块（包含区块头和区块体中的交易）广播给网络中的其他节点。

6.  **其他节点验证并接受区块 (Other Nodes Verify and Accept the Block)**:
    * 网络中的其他节点收到新区块后，会对其进行验证：
        * 检查区块头的哈希值是否确实小于当前难度目标。
        * 检查区块中的所有交易是否有效（签名、余额等）。
        * 检查区块头中的“前一区块哈希”是否指向当前他们认可的主链的最新区块。
    * 如果验证通过，其他节点就会接受这个新区块，并将其添加到自己的区块链副本的末端。他们也会停止基于上一个区块的挖矿工作，转而开始在新接收到的这个区块基础上构建下一个区块。

7.  **获得奖励 (Receiving Rewards)**:
    * 成功创建新区块的矿工会获得两部分奖励：
        * **区块奖励 (Block Reward)**: 系统新生成的比特币（例如，最初是50个比特币，之后每210,000个区块减半）。这笔奖励交易被称为“Coinbase交易”，它会作为区块中第一笔交易被记录下来，收款人是该矿工。
        * **交易费 (Transaction Fees)**: 该区块中包含的所有交易所附带的交易手续费。

### 区块链如何调整当有两个或多个矿工同时创建区块的情况？

在像比特币这样的去中心化网络中，由于网络延迟等因素，完全有可能出现两个或多个矿工在几乎同一时间都找到了一个有效的 Nonce，并各自创建了一个指向同一个父区块的有效新区块。这种情况被称为**区块链分叉 (Blockchain Fork)**。


* **并行工作与区块冲突**: 文档提到“注意到各个矿工是并行工作的, 因此完全可能出现这样的情况: 某矿工收到两份不一样的新区块”。这两份区块可能：
    1.  都基于当前这个矿工的区块链的最后一个区块。
    2.  区块内容都完全合法（即所记录的交易有效）。
    3.  区块头哈希都满足难度值要求。

* **解决方案：最长链原则 (Longest Chain Rule)**:
    * 当这种情况发生时，网络中暂时会出现两个（或多个）平行的、都有效的区块链分支。
    * 比特币协议规定，**节点总是选择并扩展最长的有效链作为主链**。
    * 当一个节点同时收到两个指向同一个父区块的不同子区块时，它通常会先接受它最先收到的那个，并基于它进行挖矿。但它也会保留另一个分支的信息。
    * 接下来，当网络中的其他矿工挖出下一个区块时，他们会选择将新区块连接到他们认为当前最长的链上。
    * 假设有两个分支A和B。如果下一个区块被添加到分支A上，使得分支A比分支B长，那么遵循最长链原则的节点就会认为分支A是主链，并切换到分支A上继续工作。
    * **被抛弃的分支**: 另一条较短的分支（分支B）就会被网络抛弃。在这个被抛弃分支上的区块被称为“孤块 (Orphan Blocks)”或“陈腐区块 (Stale Blocks)”。
    * **孤块中的交易**: 这些孤块中的交易（除了Coinbase交易外）通常会重新回到内存池中，等待被后续的区块打包。这意味着这些交易并没有丢失，只是确认时间被推迟了。
    * **孤块的矿工奖励**: 挖到孤块的矿工将无法获得该区块的区块奖励和交易费，因为这个区块没有被主链接受。

* **收敛性**: 随着时间的推移和新区块的不断产生，网络会逐渐在一条链上达成共识，这个分叉通常很快就会解决（通常在一两个区块的时间内）。一个区块被添加到主链后，其后面连接的区块越多（即“确认数”越多），该区块被推翻（即成为孤块）的可能性就越小。这就是为什么通常建议等待多个区块确认（例如比特币是6个区块确认）后，才认为一笔交易是最终不可逆的。

* **树状组织账本**: 文档第36页提到：“答:不应该以线性方式组织账本,而应该以树状组织账本,任何时刻,都以当前最长分支作为主账本,但是保留其它分支”。这形象地描述了节点如何处理潜在的分叉情况。

总结来说，矿工创建区块是一个包含交易收集、验证、区块构建和激烈计算竞赛（工作量证明）的过程。当出现并发区块导致分叉时，区块链通过“最长链原则”来保证网络最终能达成共识，选择一条唯一的主链向前发展。这个机制是区块链去中心化和安全性的重要保障。


## Web 和 电子商务安全

### 一、Web与电子商务安全需求分析

**基本背景与定义**:
Web（万维网）由蒂姆·伯纳斯-李于1989年发明，旨在促进信息共享。图形化浏览器的普及推动了其广泛应用。电子商务的概念早于互联网，但基于互联网的电子商务活动，特别是通过Web应用，因其便捷、低成本而成为主流。

**核心安全需求**:
Web与电子商务环境下的核心安全需求包括：
* **保密性 (Confidentiality)**: 防止信息泄露给未经授权的个体。
* **完整性 (Integrity)**: 确保信息在传输或存储过程中不被未授权篡改。
* **可用性 (Availability)**: 保证授权用户在需要时可以访问信息和相关资源，需抵御拒绝服务攻击。
* **可认证性 (Authentication)**: 验证通信方身份的真实性。
* **抗抵赖性 (Non-repudiation)**: 防止通信方否认其已发送或接收的信息。
* **隐私保护 (Privacy)**: 保护个人信息的收集、使用和披露。

**面临的威胁**:
* **Web系统固有脆弱性**:
    * **外部可见性**: Web服务通常暴露于外网。
    * **软件漏洞**: 复杂的Web应用软件可能包含未被发现的安全漏洞。
    * **配置与管理**: 站点易于配置但也可能因配置不当引入风险。
    * **攻击跳板**: 可能被用作攻击内部网络的跳板。
    * **用户意识**: 用户缺乏安全意识也是一个重要因素。
* **主要威胁类型**:
    * **网络通信层面**: 缺乏保密性、完整性等基本安全保障，易遭受网络窃听和报文篡改。
    * **服务端威胁**:
        * **钓鱼站点 (Phishing)**: 伪造合法网站骗取用户敏感信息（如密码）。
        * **弱安全性站点**: 安全防护不足的网站易遭受攻击，泄露用户数据，攻击者可能利用泄露的凭证尝试登录其他高安全性站点。
    * **客户端威胁**: 恶意软件，如间谍软件、特洛伊木马等，可能窃取用户本地信息。
* **DNS安全**: 域名系统（DNS）的安全性也是一个考虑因素，虽然有DNSSEC、DoH、DoT等技术提升安全，但传统DNS仍广泛使用，存在被劫持和欺骗的风险。

### 二、安全套接字协议SSL与传输层安全协议TLS

**历史与演进**:
SSL (Secure Socket Layer) 最初由Netscape开发，用于保障网络通信安全。后被IETF标准化并更名为TLS (Transport Layer Security)。TLS经历了多个版本的迭代，如TLS 1.0, 1.1, 1.2, 以及最新的TLS 1.3，每个版本都在安全性和性能上有所增强。

**协议定位与功能**:
SSL/TLS位于应用层协议（如HTTP, FTP）和TCP/IP协议的传输层（TCP）之间，为上层应用数据提供加密、完整性校验和身份认证服务。

**提供的安全服务**:
* **保密性**: 通过对称加密算法加密传输的数据。
* **数据完整性**: 使用消息认证码（MAC）确保数据在传输过程中未被篡改。
* **身份认证**: 通常至少对服务器进行身份认证（通过数字证书），也可实现客户端身份认证。

**协议体系结构**:
主要包含两层：
* **SSL/TLS记录协议 (Record Protocol)**: 负责对应用数据进行分段、压缩（可选）、添加MAC、加密，并附加记录头部，然后传递给TCP层。
* **上层协议**:
    * **SSL/TLS握手协议 (Handshake Protocol)**: 协商加密套件、交换密钥、进行身份认证。这是协议中最复杂的部分。
    * **SSL/TLS密码变化规格协议 (Change Cipher Spec Protocol)**: 通知对端后续通信将采用新协商的加密参数。
    * **SSL/TLS警告协议 (Alert Protocol)**: 用于传递错误或警告信息。

**SSL/TLS握手协议核心流程**:
1.  **Hello阶段**: 客户端和服务器交换`ClientHello`和`ServerHello`消息，协商协议版本、随机数、会话ID（可选）、以及将要使用的密码套件（密钥交换算法、加密算法、MAC算法等）。
2.  **证书与密钥交换阶段**: 服务器通常会发送其数字证书给客户端以证明身份。然后进行密钥交换（如使用RSA、Diffie-Hellman等算法）以生成后续对称加密所需的共享密钥（预主密钥，进而生成主密钥和会话密钥）。服务器也可能请求客户端证书。
3.  **加密通信开始**: 双方发送`ChangeCipherSpec`消息，并用协商好的密钥和算法发送一条加密的`Finished`消息，以验证握手过程的完整性。此后，应用数据将使用协商好的会话密钥进行加密传输。

**TLS 1.3 的重要改进**:
* **安全性增强**: 移除了过时和不安全的加密算法与特性（如RSA密钥传输、静态DH、弱哈希算法、DSA证书等），强制要求前向保密。
* **性能提升**: 简化了握手过程，将典型的2-RTT（往返时间）握手减少到1-RTT，甚至支持0-RTT模式（对于最近访问过的站点），显著降低延迟。
* **隐私保护**: 握手过程中更多的消息被加密。

### 三、安全电子交易 (SET)

**概述**:
SET (Secure Electronic Transactions) 是一套由Mastercard和Visa等机构联合推出的开放性规范，旨在为互联网上的信用卡支付交易提供安全保障。它并非一个支付系统本身，而是一系列安全协议和数据格式标准。

**主要目标与服务**:
* **安全通信**: 保证交易各方之间通信的保密性和数据完整性。
* **身份认证**: 基于X.509数字证书体系对持卡人、商户和收单行等参与方进行身份认证。
* **隐私保护**: 通过特殊机制（如双重数字签名）确保敏感信息（如信用卡号、订单详情）只被授权方获取。

**核心技术：双重数字签名 (Dual Signature)**:
双重数字签名是SET中一项关键技术，它允许将订单信息（OI，Order Information）和支付指令（PI，Payment Instructions）安全地关联起来，同时对不同参与方隐藏不必要的信息：
* **商户**: 可以看到订单信息（OI）以处理订单，但无法看到持卡人的完整支付信息（如信用卡号）。
* **支付网关/银行**: 可以看到支付指令（PI）以完成支付授权和清算，但通常不需要订单的详细内容。
通过双重签名，可以确保OI和PI都来自同一个持卡人且未被篡改，并将两者牢固绑定。

**SET参与方**:
包括持卡人 (Cardholder)、商户 (Merchant)、发卡行 (Issuer)、收单行 (Acquirer)、支付网关 (Payment Gateway) 和证书颁发机构 (CA)。

**基本交易流程**: 涉及客户开户获取证书、商户验证、客户下单、订单与支付信息安全发送、商户向支付网关请求授权、订单确认、商品/服务提供及最终的支付请求等步骤。SET强调的是在线信用卡交易的安全性。

